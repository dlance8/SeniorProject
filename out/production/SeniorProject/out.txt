private boolean compilationUnit() {
	return accept(Nonterminal.COMPILATION_UNIT, this::classDeclaration);
}
private boolean classDeclaration() {
	return accept(Nonterminal.CLASS_DECLARATION, () -> acceptAll(() -> acceptRepeating(this::classModifier), () -> accept(Terminal.CLASS), this::className, () -> acceptOptional(this::superClass), () -> acceptOptional(this::superInterfaces), this::classBody));
}
private boolean classModifier() {
	return accept(Nonterminal.CLASS_MODIFIER, () -> acceptAny(() -> accept(Terminal.PUBLIC), () -> accept(Terminal.PROTECTED), () -> accept(Terminal.PRIVATE), () -> accept(Terminal.ABSTRACT), () -> accept(Terminal.STATIC)));
}
private boolean className() {
	return accept(Nonterminal.CLASS_NAME, this::identifier);
}
private boolean superClass() {
	return accept(Nonterminal.SUPER_CLASS, () -> acceptAll(() -> accept(Terminal.EXTENDS), this::className));
}
private boolean superInterfaces() {
	return accept(Nonterminal.SUPER_INTERFACES, () -> acceptAll(() -> accept(Terminal.IMPLEMENTS), this::interfaceName, () -> acceptRepeating(() -> acceptAll(() -> accept(Terminal.COMMA), this::interfaceName))));
}
private boolean interfaceName() {
	return accept(Nonterminal.INTERFACE_NAME, this::identifier);
}
private boolean classBody() {
	return accept(Nonterminal.CLASS_BODY, () -> acceptAll(() -> accept(Terminal.OPEN_BRACE), () -> acceptRepeating(this::classMemberDeclaration), () -> accept(Terminal.CLOSE_BRACE)));
}
private boolean classMemberDeclaration() {
	return accept(Nonterminal.CLASS_MEMBER_DECLARATION, () -> acceptAny(this::mainMethodDeclaration, () -> accept(Terminal.SEMICOLON)));
}
private boolean mainMethodDeclaration() {
	return accept(Nonterminal.MAIN_METHOD_DECLARATION, () -> acceptAll(() -> accept(Terminal.PUBLIC), () -> accept(Terminal.STATIC), () -> accept(Terminal.VOID), () -> identifier("main"), () -> accept(Terminal.OPEN_PARENTHESIS), () -> identifier("String"), () -> accept(Terminal.OPEN_BRACKET), () -> accept(Terminal.CLOSE_BRACKET), this::identifier, () -> accept(Terminal.CLOSE_PARENTHESIS), this::methodBody));
}
private boolean methodBody() {
	return accept(Nonterminal.METHOD_BODY, () -> acceptAll(() -> accept(Terminal.OPEN_BRACE), () -> acceptRepeating(this::methodStatement), () -> accept(Terminal.CLOSE_BRACE)));
}
private boolean methodStatement() {
	return accept(Nonterminal.METHOD_STATEMENT, () -> acceptAny(this::printStatement, () -> accept(Terminal.SEMICOLON)));
}
private boolean printStatement() {
	return accept(Nonterminal.PRINT_STATEMENT, () -> acceptAll(() -> identifier("System"), () -> accept(Terminal.DOT), () -> identifier("out"), () -> accept(Terminal.DOT), () -> identifier("println"), () -> accept(Terminal.OPEN_PARENTHESIS), this::expression, () -> accept(Terminal.CLOSE_PARENTHESIS), () -> accept(Terminal.SEMICOLON)));
}
private boolean expression() {
	return accept(Nonterminal.EXPRESSION, this::stringLiteral);
}

